# Task ID: 13
# Title: Implement Currency Sorting by Popularity
# Status: done
# Dependencies: 3, 9
# Priority: medium
# Description: Develop the logic to sort currencies by popularity based on user usage patterns.
# Details:
Implement a service to sort currencies by popularity based on the user's usage patterns. This service should use the CurrencyUsage data to determine which currencies are most used by the user.

Code example:
```kotlin
class CurrencySortingService @Inject constructor(
    private val currencyUsageRepository: CurrencyUsageRepository,
    private val userRepository: UserRepository
) {
    suspend fun getSortedCurrencies(userId: Long): List<Currency> {
        // Get user's currency usage
        val userCurrencyUsage = currencyUsageRepository.getUserCurrenciesSortedByUsage(userId)
        
        // Get user's default currency
        val user = userRepository.getUserById(userId)
        val defaultCurrency = user?.defaultCurrency ?: "USD"
        
        // Create a set of used currencies
        val usedCurrencyCodes = userCurrencyUsage.map { it.currency }.toSet()
        
        // Ensure default currency is included
        val allUsedCodes = usedCurrencyCodes + defaultCurrency
        
        // Get all currencies
        val allCurrencies = Currency.values().toList()
        
        // Sort currencies: first by usage (if used), then by default enum popularity
        return allCurrencies.sortedWith(compareBy(
            // First sort by whether it's in the used set (used currencies first)
            { !(it.code in allUsedCodes) },
            // Then sort used currencies by their usage order
            { code -> userCurrencyUsage.indexOfFirst { it.currency == code } },
            // Finally sort by the default popularity for currencies not in the used set
            { it.popularity }
        ))
    }
}
```

Implement caching to avoid repeated database queries. Use Kotlin Flow (from kotlinx.coroutines-flow) to observe changes in currency usage and update the sorted list automatically.

# Test Strategy:
Write unit tests to verify that:
1. Currencies are correctly sorted by usage
2. Default currency is included even if not used
3. Unused currencies are sorted by default popularity
4. Changes in usage patterns update the sorting
5. Edge cases are handled (no usage data, all currencies used equally)
6. Performance testing with large datasets

# Subtasks:
## 1. Create CurrencyUsageRepository Interface and Implementation [done]
### Dependencies: None
### Description: Define and implement the repository interface for accessing currency usage data from the database. This repository will provide methods to retrieve user currency usage patterns sorted by frequency.
### Details:
Create a CurrencyUsageRepository interface with methods like getUserCurrenciesSortedByUsage(userId: Long) and getUserCurrencyUsage(userId: Long, currencyCode: String). Implement this interface with a class that uses Room or your database access layer to retrieve and sort currency usage data. Include methods to observe changes in currency usage patterns using Kotlin Flow.
<info added on 2025-09-05T17:20:07.019Z>
Update the CurrencyUsageRepository interface and its implementation to add the missing method `getUserCurrenciesSortedByUsage(userId: Long)`. This method should return a Flow<List<CurrencyUsage>> containing the user's currencies sorted by usage count in descending order. The implementation should leverage the existing database structure and query capabilities.

In the interface:
```kotlin
fun getUserCurrenciesSortedByUsage(userId: Long): Flow<List<CurrencyUsage>>
```

In the implementation class:
```kotlin
override fun getUserCurrenciesSortedByUsage(userId: Long): Flow<List<CurrencyUsage>> {
    return currencyUsageDao.getCurrencyUsageByUserSortedByCount(userId)
}
```

Ensure the DAO also has the corresponding method:
```kotlin
@Query("SELECT * FROM currency_usage WHERE user_id = :userId ORDER BY usage_count DESC")
fun getCurrencyUsageByUserSortedByCount(userId: Long): Flow<List<CurrencyUsage>>
```

This implementation will build on the existing repository structure while adding the specific sorting functionality required by the task.
</info added on 2025-09-05T17:20:07.019Z>

## 2. Implement Core Currency Sorting Logic [done]
### Dependencies: 13.1
### Description: Develop the core sorting algorithm that orders currencies based on user usage patterns, ensuring the default currency is always included and unused currencies are sorted by default popularity.
### Details:
Implement the getSortedCurrencies method in CurrencySortingService as shown in the example. Ensure the sorting logic correctly prioritizes: 1) User's frequently used currencies, 2) User's default currency, and 3) Remaining currencies by their default popularity. Handle edge cases like no usage data or when all currencies are used equally.
<info added on 2025-09-05T17:21:34.030Z>
Successfully implemented the core currency sorting logic in CurrencySortingService:

1. Created CurrencySortingService in domain/usecase package
2. Implemented getSortedCurrencies() method that returns Flow<List<Currency>>
3. Implemented getSortedCurrenciesSuspend() method for suspend-based usage
4. Added helper methods: getTopCurrencies() and getUsedCurrencies()
5. Added proper dependency injection setup in RepositoryModule

The sorting logic correctly prioritizes:
- User's frequently used currencies (by usage count)
- User's default currency (always included)
- Remaining currencies by their default popularity ranking

The service handles edge cases and provides both Flow-based reactive updates and suspend-based synchronous access.
</info added on 2025-09-05T17:21:34.030Z>

## 3. Add Caching Mechanism for Sorted Currencies [done]
### Dependencies: 13.2
### Description: Implement a caching layer to avoid repeated database queries when retrieving sorted currencies. The cache should invalidate when currency usage patterns change.
### Details:
Add an in-memory cache to store the sorted currency list. Implement cache invalidation logic that triggers when currency usage data changes. Use a combination of time-based expiration and explicit invalidation when usage patterns are updated. Consider using a library like Caffeine for sophisticated caching capabilities.
<info added on 2025-09-05T17:22:45.375Z>
Successfully implemented caching mechanism for the CurrencySortingService:

1. Added in-memory cache using ConcurrentHashMap for thread safety
2. Implemented cache expiration (5 minutes) with timestamp tracking
3. Added thread-safe cache operations using Mutex
4. Enhanced getSortedCurrenciesSuspend() to use cache with fallback to repository
5. Added cache invalidation methods:
   - invalidateCache(userId) for specific user
   - invalidateAllCache() for all users
6. Added trackCurrencyUsage() method that increments usage and invalidates cache
7. Added getCacheStats() for debugging and monitoring
8. Cache automatically invalidates when currency usage patterns change

The caching system provides significant performance improvements by avoiding repeated database queries while ensuring data consistency through proper invalidation.
</info added on 2025-09-05T17:22:45.375Z>

## 4. Implement Reactive Updates with Kotlin Flow [done]
### Dependencies: 13.3
### Description: Enhance the currency sorting service to use Kotlin Flow for observing changes in currency usage and automatically updating the sorted list when patterns change.
### Details:
Modify the CurrencySortingService to expose a Flow<List<Currency>> that emits updated sorted currency lists whenever usage patterns change. Use the Flow APIs from the currencyUsageRepository to observe database changes. Implement proper coroutine scope management and error handling within the flows.

## 5. Integrate Currency Sorting Service with UI Components [done]
### Dependencies: 13.4
### Description: Connect the CurrencySortingService with UI components that display currency lists, ensuring they update reactively when usage patterns change.
### Details:
Create extension functions or utility methods to easily consume the sorted currency Flow in ViewModels. Implement proper lifecycle awareness when collecting flows in UI components. Add methods to filter or further customize the sorted list for specific UI needs (e.g., showing only top N currencies). Ensure the service is properly injected using dependency injection.

